\section{Neural Networks}

\subsection{Deep Learning}

The concepts of deep learning studied in this section is going to be based on the work of \citet{goodfellow2016} and the documentation of PyTorch\footnote{\url{https://pytorch.org/docs/stable/index.html}} and MATLAB\footnote{\url{https://www.mathworks.com/help/matlab/}}.

There are several definitions of \gls*{ai} \citep{winston1992}, but the  computer scientist \citet{mccarthy2007} defines it as ``the science and engineering of making intelligent machines, especially intelligent computer programs.''.
He also states that ``it is related to the similar task of using computers to understand human intelligence, but AI does not have to confine itself to methods that are biologically observable.''.

The big area of study is the \gls*{ai} and it includes several branches like fuzzy logics, robotics, machine learning and so on. 
The later one, in turn, is another field with also some branches and one of them is the deep learning.
This can be represented in a Venn diagram, as the \cref{fig:venn_dl} shows.
However, all the three terms can be interchangeable in the major context.

\begin{figure}[!htb]
    \centering
    \includegraphics{figures/2review/nn/venn_dl.pdf}
    \caption{Subareas of Artificial Intelligence}
    \label{fig:venn_dl}
\end{figure}

The deep learning history goes back to the 1940s and it had several names over the years. 
It was called by \emph{cybernetics} (1940s--1960s), \emph{connectionism} (1980s--1990s), and from 2006 until now is known as \emph{deep learning}.
The \gls*{dl} models were engineered systems inspired by the biological brain and they were denominated \gls*{ann}.
One of the motivations of the neural  perspective was to understand that the brain provides a proof by example that intelligent behavior is possible and try to reverse engineer the computation principals behind the brain, duplicating its functionality.

\gls*{dl} today goes beyond the neuroscientist perspective and it is more of general principle of learning multiple levels of composition.

\subsection{Neural Networks Models}

\subsection{Loss Function}

The \emph{loss function}, also called \emph{cost function} or \emph{error function}, is the one used measure the error between the predicted output of an algorithm and the real target output. 
There are several loss functions suitable to different kind of situation. For each distributed data there is one that fits better.

\begin{figure}[!htb]
    \centering
    \includegraphics{figures/2review/nn/mae_chart.pdf}
    \caption[Linear Data and Loss Function]{Linear Data and Loss Function. The loss function take all the distances between the predicted and the target value to verify if the model is in the right path. The lower the distance, the better.}
    \label{fig:mae_chart}
\end{figure}

For a linear distribution of the data, for instance, a common loss function adopted is the \gls*{mae}.
%
\begin{equation}
    \mae = \frac{1}{n} \sum_{i=1}^n |y_i - x_i|
    \label{eq:mae}
\end{equation}
%
where \(n\) is the sample size; \(y_i\) is the predicted output; and \(x_i\) is the real target. Or the \gls*{mse} \cite{bussab2017}:
%
\begin{equation}
    \mse = \frac{1}{n} \sum_{i=1}^n (\hat{y}_i - y_i)^2
    \label{eq:mse}
\end{equation}
%
where \(n\) is the sample size; \(\hat{y}_i\) is the predicted output; and \(y_i\) is the real target.

\gls*{mae} and \gls*{mse} are simple methods and both lead to poor results for complex data patterns
Although, through them, it is easy to recognize the essence of what the cost function does. 
Other methods like \emph{cross-entropy} are more likely to get better results when having a pattern of complex data.

Therefore, the loss function measures how far from the real value the data is. Many kinds of them are available and must be analyzed the most proper one to each case. 
It will depend on not only the data and its pattern, but also the computational processing and the cost attached to it.

\subsubsection*{Cross Entropy}

\subsubsection*{Binary Cross Entropy}

\subsection{Optimizer}

The optimizer is an algorithm that updates the model in response to the output of the loss function, that is, it aids minimizing the loss function. 
As the loss function minimizes, the model is getting closer to the target values and, hence, closer to the real pattern.

The \emph{gradient descent} is one of the main algorithm \citep{nesterov2004} that optimizes the model and many important ones are based on it, like the \gls*{sgd}. The goal is to get the minimum, as the error (loss) between the predicted and the target data is null. This would mean that the model fits to the pattern of the data.
%
\begin{figure}[H]
    \centering
    \includegraphics{figures/2review/nn/gradient_descent.pdf}
    \caption[Gradient Descent Process]{Gradient Descent Process. In this case, the loss function can be represented in a two-axes plan. Depending on the data, it is not possible to represent graphically due to its multi dimension.}
\end{figure}

\subsubsection*{Gradient Descent}

The gradient descent is a powerful algorithm that reduces the loss function, minimizing the error between the predicted value and the target value.

Since the gradient of a function gives the direction of the steepest ascent of a function and it is orthogonal to the surface at a determined point, it seems reasonable that moving in the perpendicular direction gives the maximum increase of the function \cite{stewart2016}.
On the other hand, the negative of the gradient may be used to find the opposite, that is, the minimum decrease of the function.
If the steps given to the direction of the negative gradient of the function are small, there is a good chance to get minimum value of the function.
However, if the steps are too long, the chance to pass by the minimum value is high \citep{nielsen2015}.
These steps are called \emph{learning rate} and should be chosen wisely.

This way, let \(\vb{x}\) be the entry vector with the predicted data and \(L\) the loss function adopted for some deep learning model, and \(\gamma\) the learning rate, the gradient descent is:
%
\begin{equation}
    x_{t+1} = x_t - \gamma\nabla L(x_t)
\end{equation}
%
Therefore, the gradient descent gets the loss function tending to its minimum possible value.

\subsubsection*{Stochastic Gradient Descent}

As seen, gradient descent is a powerful tool to minimize the loss function, however, for large data, the cost of operation is very high and its use is not feasible. 
The main ideia of \gls*{sgd} is that the gradient is an expectation.
Later, the data is divided in subsets, also called \emph{mini-batches} and then the gradient is performed over them.
The data inside each subset may be considered redundant, that is why it uses one single value of the subset to compute the gradient descent.
This way, the process is considerable better for computational resources.

The \gls*{sgd} can be written as:
%
\begin{equation}
    \vb{x}_{t+1} = \vb{x}_t - \frac{\gamma}{m} \sum_{i=1}^m \nabla L(\vb{x}_t; p^{(i)},q^{(i)})
\end{equation}
%
where \(m\) is the mini-batch size, and \(\nabla L(\theta; p^{(i)}, q^{(i)})\) is the gradient of the loss function with respect to the parameter vector \(\vb{x}\) for the \(i^{\text{th}}\) example \((p^{(i)}, q^{(i)})\) in the mini-batch.

Yet, nowadays, with the amount of data, many techniques are still applied in \gls*{sgd} as creating an automatic adaptive learning rates which achieve the optimal rate of convergence \citep{darken1991} and the momentum technique to improve it \citep{sutskever2013}.

% \subsection{Perceptron}

% \subsubsection*{Single-Layer Perceptron}

% A \gls*{slp} is a supervised learning algorithm that provides binary classifiers. It is the simplest kind of \gls*{ann}, but the complex ones are based on it and it serves to solve many problems yet.

% \begin{figure}[!htb]
%     \centering
%     \includegraphics{figures/2review/nn/perceptron.pdf}
%     \caption[Perceptron Scheme]{Perceptron Scheme. It is a simple machine learning algorithm that provides a binary output. It resembles a human neuron: input layer data is equivalent to the dendrites; hidden layers are the equivalent of the axons; and the output layer are the equivalent of the nerve ending.}
%     \label{fig:perceptron}
% \end{figure}

% The principle is quite simple, from the input data \(\mathbf{x}\) and initial random weights \(\mathbf{w}\), it returns the weighted sum \(f(\mathbf{x},\mathbf{w})\). This is graphically represented in the~\cref{fig:perceptron}.
% %
% \begin{equation}\label{eq:perceptron_weighted_sum}
%     f(\mathbf{x},\mathbf{w}) = \sum_{i=1}^n x_iw_i =  x_1w_1 + x_2w_2 + \cdots + x_nw_n
% \end{equation}
% %
% where \(\mathbf{x}\) is a vector containing the input data and \(\mathbf{w}\) is a vector containing the weights, both with \(n\) elements.

% It splits the data with a straight line classifying them in two groups and that is the reason it is a binary classifier.

% \begin{figure}[!htb]
%     \centering
%     \includegraphics{figures/2review/nn/perceptron_charge.pdf}
%     \caption[Perceptron Behavior]{Perceptron Behavior. It is a binary classifier.}
% \end{figure}

% Surely, for the first iteration, the output should not be the best one and the procedure must begin from the start, but now with the new values obtained. Then, for each iteration it tends to get better and learn to label each received data.

% \subsubsection*{Multilayer Perceptron}
 
% A \gls*{mlp}, also known as \emph{deep network}, \emph{feedforward neural networks} or \emph{deep feedforward networks}, is the essence of \gls*{dl}. Basically, it is a mathematical function, formed by composing many simpler functions, mapping some set of input values to output values.
% %
% \begin{figure}[!htb]
%     \centering
%     \includegraphics{figures/2review/nn/mlp.pdf}
%     \caption[Multilayer Perceptron Scheme]{Multilayer Perceptron Scheme. The figure show two hidden layers, totalizing eight neurons. A \gls*{mlp} accepts multiple hidden layers and neurons. It can also have several outputs.}
% \end{figure}

% It increases the complexity and gives a more complete machine training, allowing results even more precise, when compared to the \gls*{slp}.