\section{Neural Network for \gls*{uav} Control}

\subsection{Data Generation}

Since the script of \citet{geronel2023} provides the control torque \(\symbfup{\tau}_{\eta}\) as input and the state-space \(\symbf{x}_s\) as output vector through dynamic and control equations, the \gls*{nn} goal developed here is to do the opposite: take \(\symbf{x}_s\) as the input vector and predict the \(\symbfup{\tau}_{\eta}\) vector as output.

The modifications in the script are minimal.
The time is a discrete vector with \SI{250}{s} and step 0.01, therefore the time vector has \(1\times 25001\) dimension.
The ``extra'' value of time is the zero value.

The output vector \(\tau_{\eta}\) has \(25001\times 4\) dimension the and the input vector \(\symbf{x}_s\) has  \(25001\times 12\) dimension.
%
\begin{equation}\label{eq:tau_input}
    \symbfup{\tau}_{\eta} = \begin{bmatrix}
        a_{1,1}      & a_{1,2}      & a_{1,3}      & a_{1,4} \\
        \vdots       & \vdots       & \vdots       & \vdots  \\
        a_{25001, 1} & a_{25001, 2} & a_{25001, 3} & a_{25001, 4} 
    \end{bmatrix}
\end{equation}
%
where the matrix column represents the control torques \(U_i\) (\(i=1,2,3,4\)).
%
\begin{equation}\label{eq:xs_output}
    \symbf{x}_s = \begin{bmatrix}
        b_{1,1}      & \cdots & b_{1,12} \\
        \vdots       & \ddots & \vdots \\
        b_{25001, 1} & \cdots & b_{25001, 12} 
    \end{bmatrix}
\end{equation}
%
where each column represents the elements of the vector in the~\cref{eq:xs_vector_matlab}.

This way, the rectangular trajectory was arbitrary selected they were generated by a loop, changing the position and the velocity increasing 0.02 for each loop.
It was generated 100 different trajectories.

Those informations are summarized in the~\cref{tab:data_generation_uav}
\begin{table}[!htb]
    \centering
    \caption[Data generation for the \gls*{uav}]{Data generation for the \gls*{uav}.}
    \begin{tblr}{ll}
    \toprule
    Parameter & Value           \\
    \midrule
    Trajectory    & Circular    \\
    Increase step & 0.2         \\
    Time          & \SI{250}{s} \\
    Time step     & 0.01        \\
    \bottomrule
    \end{tblr}
    \begin{flushleft}\footnotesize
        Source: prepared by the author.
    \end{flushleft}
    \label{tab:data_generation_uav}
\end{table}

From there, it was generated one thousand input and output vector.
Both were stored in a \matlab variable and exported through the \texttt{.mat} extension to be used with TensorFlow inside a Python environment.
\section{Modeling the Neural Network with TensorFlow}

The problem was considered as a regression problem due its nature, as the~\cref{eq:function_training_model_uav} shows. Note that the input and output are all vector.
%
\begin{equation}\label{eq:function_training_model_uav}
    f\big(\symbf{p}_1(t),\symbf{p}_2(t),\ldots,\symbf{p}_{12}(t)\big) = \langle \symbf{u}_1(t),\symbf{u}_2(t),\symbf{u}_3(t),\symbf{u}_4(t) \rangle
\end{equation}
% \begin{equation}\label{eq:function_training_model_uav}
%     f(\dot{\symbf{x}},\dot{\symbf{y}},\dot{\symbf{z}}\dot{\symbf{\phi}},\dot{\symbf{\theta}},\dot{\symbf{\psi}},\symbf{x},\symbf{y},\symbf{z},\symbf{\phi},\symbf{\theta},\symbf{\psi}) = \langle \symbf{u}_1(t),\symbf{u}_2(t),\symbf{u}_3(t),\symbf{u}_4(t) \rangle
% \end{equation}

In order to consume less computer processing, the number of epochs is going to be reduced, but to have a good model, the number of artificial neurons will be increased.





